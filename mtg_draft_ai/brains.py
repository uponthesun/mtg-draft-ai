"""Implementations of Picker, which (hopefully) use intelligent strategies to make draft picks."""

import collections
import random
import itertools
import networkx as nx
from mtg_draft_ai import synergy
from mtg_draft_ai.api import Picker


COLORS = ['W', 'U', 'B', 'R', 'G']
COLOR_PAIRS = [''.join(tup) for tup in itertools.combinations(COLORS, 2)]


class RandomPicker(Picker):
    """Makes totally random picks. Used for prototyping purposes."""

    def pick(self, pack, cards_owned, draft_info, state):
        """Makes a random pick from a pack.

        Args:
            pack (List[Card]): The current pack to pick a card out of.
            cards_owned (List[Card]): The cards already owned.
            draft_info (DraftInfo): Information about the draft configuration.
            state (Dict[str, str]): Any additional state used by picker implementations.

        Returns:
            Card: The picked card.
        """
        return pack[random.randint(0, len(pack) - 1)]


class Factory:

    def __init__(self, output_class, kwargs):
        self.output_class = output_class
        self.kwargs = kwargs

    def create(self):
        return self.output_class(**self.kwargs)


_GSPRating = collections.namedtuple('Rating', ['card', 'color_combo', 'total_edges',
                                               'common_neighbors_weighted', 'default'])


class GreedySynergyPicker(Picker):
    """Attempts to maximize number of synergy edges, for the color pair with the most edges in its pool."""

    def __init__(self, default_ratings, common_neighbors):
        """Basic init method which does no manipulation of its parameters.

        For most cases, use GreedySynergyPicker.factory(card_list).create() instead.

        Args:
            default_ratings ({Card: float}): A default rating for each card.
            common_neighbors ({Card: {Card: List[Card]}}): Generated by all_common_neighbors function
        """
        self.default_ratings = default_ratings
        self.common_neighbors = common_neighbors

    @staticmethod
    def factory(card_list):
        """Creates a factory for GreedySynergyPicker instances.

        Performs potentially expensive precomputations, which can be reused to create multiple instances.

        Args:
            card_list (List[Card]): List of all cards in the cube.

        Returns:
            Factory: a factory for GreedySynergyPicker instances, with a no-arguments create() method.
        """
        syn_graph = synergy.create_graph(card_list)

        # Default rating is currently based on centrality, but likely we could find a better measure.
        defaults = nx.eigenvector_centrality(syn_graph)
        for card in card_list:
            defaults.setdefault(card, 0)

        common_neighbors = all_common_neighbors(syn_graph, card_list)

        kwargs = {'default_ratings': defaults,
                  'common_neighbors': common_neighbors}
        return Factory(GreedySynergyPicker, kwargs)

    def pick(self, pack, cards_owned, draft_info, state):
        self._update_signals(state, pack)

        ranked_candidates = self._ratings(pack, cards_owned)

        # replace full card object with just card name for more readable output
        printable_candidates = [str(_GSPRating(tup[0].name, *tup[1:])) for tup in ranked_candidates]
        print('\nrankings: {}'.format('\n'.join(printable_candidates)))

        return pack[0] if len(ranked_candidates) == 0 else ranked_candidates[0][0]

    @staticmethod
    def _update_signals(state, pack):
        color_counts_key = 'color_counts'
        if color_counts_key not in state:
            state[color_counts_key] = _init_color_counts()

        for card in pack:
            if card.color_id != 'C' and len(card.color_id) <= 2:
                state[color_counts_key][_standardized_colors(card.color_id)] += 1

    def _ratings(self, pack, cards_owned):
        candidates = []

        for color_combo in COLOR_PAIRS:
            on_color_cards = [c for c in cards_owned if synergy.castable(c, color_combo)]
            on_color_candidates = [c for c in pack if synergy.castable(c, color_combo)]

            for candidate in on_color_candidates:
                cards_with_candidate = on_color_cards + [candidate]
                syn_graph = synergy.create_graph(cards_with_candidate)

                # Number of edges in the graph for the card pool plus the candidate.
                total_edges = len(syn_graph.edges)

                # Measure of improvement of future pick quality based on common neighbors between pool and candidate.
                common_neighbors_weighted = self._common_neighbors_weighted(on_color_cards, candidate, color_combo)
                default = self.default_ratings[candidate]

                candidates.append(_GSPRating(candidate, color_combo, total_edges, common_neighbors_weighted, default))

        # Lexicographic sort of the fields in the rating tuple (excluding the card and color combo)
        candidates.sort(key=lambda tup: tup[2:], reverse=True)
        return candidates

    def _common_neighbors_weighted(self, card_pool, candidate, colors):
        """Sums # of common neighbors between candidate and each card in the pool."""
        neighbor_count = 0

        for c in card_pool:
            valid_neighbors = [n.name for n in self.common_neighbors[candidate][c]
                               if synergy.castable(n, colors)
                               if n not in card_pool]
            neighbor_count += len(valid_neighbors)

        return neighbor_count


def all_common_neighbors(graph, cards):
    """Computes common neighbors for all pairs of cards.

    Args:
        graph (networkx.Graph): The graph to compute common neighbors for.
        cards (List[Card]): Cards to compute common neighbors for. (May include
            cards not in the graph.)

    Returns:
        {Card: {Card: List[Card]}}: dict which allows lookup of a list of common neighbors for any pair of cards.
    """
    common_neighbors = {}

    for i in range(0, len(cards) - 1):
        for j in range(i + 1, len(cards)):
            c1, c2 = cards[i], cards[j]
            common_neighbors.setdefault(c1, {}).setdefault(c2, {})
            common_neighbors.setdefault(c2, {}).setdefault(c1, {})
            if (c1 not in graph) or (c2 not in graph):
                continue

            neighbors = list(nx.common_neighbors(graph, c1, c2))
            common_neighbors[c1][c2] = neighbors
            common_neighbors[c2][c1] = neighbors

    return common_neighbors


def _init_color_counts():
    counts = collections.OrderedDict()
    for colors in itertools.chain(COLORS, COLOR_PAIRS):
        counts[_standardized_colors(colors)] = 0
    return counts


def _standardized_colors(colors):
    return ''.join(sorted(colors, key=lambda c: COLORS.index(c)))
